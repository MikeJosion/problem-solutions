# [1015. 可被 K 整除的最小整数](https://leetcode.cn/problems/smallest-integer-divisible-by-k/)**(11.25)**

给定正整数 `k` ，你需要找出可以被 `k` 整除的、仅包含数字 `1` 的最 **小** 正整数 `n` 的长度。
返回 `n` 的长度。如果不存在这样的 `n` ，就返回-1。
**注意：** `n` 可能不符合 64 位带符号整数。

## 难点

<details><summary>**1. 为什么 ****remainder = (remainder * 10 + 1) % k;**** 可以用来表示1,11,111...**</summary>

它模拟了数字 1 → 11 → 111 → 1111 的构造过程，
并且只保留这些数字除以 k 的余数，而且不会爆数。

</details>

<details><summary>**2. 余数为什么能代表整个数字,不用真的构造 1、11、111？**</summary>

> 💡 ****
>
> 
> $$
> \begin{aligned}
> \text{resid}_{new} &= n_{new} \bmod k \\
> &= (n_{old} \times 10 + 1) \bmod k \\
> &= ((n_{old} \bmod k) \times 10 + 1) \bmod k \\
> &= (\text{resid}_{old} \times 10 + 1) \bmod k
> \end{aligned}
> $$
> 
</details>

<details><summary>**3. 为什么余数重复意味着永远不会出 0？**</summary>

余数重复 → 数字构造进入循环 → 未来余数重复过去 → 过去没有 0 → 永远不会出现 0。

</details>

## 知识点

### 🐦 鸽巢定理（抽屉原理）
> 💡 **📌核心:东西比格子多 → 至少有一个格子里会放至少两个东西**
>
> 
> ## 余数为什么最多只有 k 个？
> > 因为模 k 的余数一定落在：
> > 
> $$
> r_n \in \{0,1,2,\dots,k-1\}
> $$
> > 这是数学定义。所以无论你计算几次，余数只可能是这 **k 种**。
> > 👉 **这就像 k 个“格子”（鸽巢）**。
> > 
> ## 第二步：如果前 (k) 次没有出现 0，会发生什么？
> > 
> > 我们会得到：
> > 
> $$
> [
> r_1, r_2, \ldots, r_k
> ]
> 并且每个 ( r_i \neq 0 )。
> $$
> > 
> ---
> > 
> ### 那么它们只能落在：
> > 
> $$
> [
> {1, 2, \ldots, k-1}
> ]
> （共 (k-1) 种可能）
> $$
> > 
> ---
> > 
> ### 但是你进行了 (k) 次计算！
> > 也就是说：
> > 你做了 (k) 次运算，但结果只能落在 (k-1) 个不同的值里。
> > 
> ---
> > 
> ---
> > 
> ## 第三步：这时鸽巢定理怎么用？
> > 你把 **(k) 个余数（鸽子）**
> > 放到 **(k-1) 个可能取值（鸽巢）** 中。
> > 
> ---
> > 
> ### 根据鸽巢定理：
> > 只要鸽子比鸽巢多，就一定至少有一个鸽巢装了两只鸽子。
> > 也就是说：
> > 
> $$
> [
> r_i = r_j \quad (i < j)
> ]
> $$
> > 一定会发生 **余数重复**。
> > 
> ## 第四步：重点：余数重复为什么意味着永远不出现 0？
> > 假设：
> > 
> $$
> [
> r_i = r_j \quad (i < j)
> ]
> $$
> > 那么之后的余数序列会完全重复：
> > 
> $$
> [
> r_{i+1} = r_{j+1},\quad r_{i+2} = r_{j+2},\ldots
> ]
> $$
> > 也就是说：
> > 
> ## 🔄 构造进入循环
> > 序列
> > 
> $$
> [
> r_i,, r_{i+1},, r_{i+2}, \ldots
> ]
> $$
> > 会重复成为
> > 
> $$
> [
> r_j,, r_{j+1},, r_{j+2}, \ldots
> ]
> $$
> > 
> ---
> > 
> ### 而在循环开始之前（前 (k) 次），我们已经知道：
> > 
> $$
> [
> 0 \notin { r_1, r_2, \ldots, r_k }
> ]
> $$
> > 循环只会重复这些值。
> > 
> ---
> > 
> ## ⭐ 因此：永远不会出现 0！
> 
```java
class Solution {
    public int smallestRepunitDivByK(int k) {
        // 特判：k 为偶数或 5 的倍数，无解
        if (k % 2 == 0 || k % 5 == 0)  return -1;
        
        int remainder = 0;
        for (int len = 1; len <= k; len++) {
            remainder = (remainder * 10 + 1) % k;
            if (remainder == 0) return len;
        }
        return -1; 
    }
}
```

